{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bowser = _interopRequireDefault(require(\"bowser\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _NativeScrollbar = _interopRequireDefault(require(\"./NativeScrollbar\"));\n\nvar _Thumb = _interopRequireDefault(require(\"./Thumb\"));\n\nvar _Track = _interopRequireWildcard(require(\"./Track\"));\n\nvar _getInnerSizes = require(\"./util/getInnerSizes\");\n\nvar _getScrollbarWidth = _interopRequireDefault(require(\"./util/getScrollbarWidth\"));\n\nvar _LoopController = _interopRequireDefault(require(\"./util/LoopController\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar browser = global.window && global.window.navigator && _bowser.default.getParser(global.window.navigator.userAgent);\n\nvar engine = browser && browser.getEngine().name;\nvar defaultStyles = {\n  holder: {\n    position: \"relative\",\n    display: \"flex\"\n  },\n  wrapper: {\n    flexGrow: 1\n  },\n  content: {\n    position: \"absolute\",\n    top: 0,\n    bottom: 0,\n    right: 0,\n    left: 0\n  },\n  track: {\n    common: {\n      position: \"absolute\",\n      overflow: \"hidden\",\n      borderRadius: 4,\n      background: \"rgba(0,0,0,.1)\",\n      userSelect: \"none\"\n    },\n    x: {\n      height: 8,\n      width: \"calc(100% - 16px)\",\n      bottom: 0,\n      left: 8\n    },\n    y: {\n      width: 8,\n      height: \"calc(100% - 16px)\",\n      top: 8\n    }\n  },\n  thumb: {\n    common: {\n      cursor: \"pointer\",\n      borderRadius: 4,\n      background: \"rgba(0,0,0,.4)\"\n    },\n    x: {\n      height: \"100%\"\n    },\n    y: {\n      width: \"100%\"\n    }\n  }\n};\n/**\n * @typedef {object} ScrollValues\n *\n * @property {number|null} clientHeight - content's native clientHeight parameter\n * @property {number|null} clientWidth - content's native clientWidth parameter\n * @property {number|null} scrollHeight - content's native scrollHeight parameter\n * @property {number|null} scrollWidth - content's native scrollWidth parameter\n * @property {number|null} scrollTop - content's native scrollTop parameter\n * @property {number|null} scrollLeft - content's native scrollLeft parameter\n * @property {boolean|null} scrollYBlocked - Indicates whether vertical scroll blocked via properties\n * @property {boolean|null} scrollXBlocked - Indicates whether horizontal scroll blocked via properties\n * @property {boolean|null} scrollYPossible - Indicates whether the content overflows vertically and scrolling not blocked\n * @property {boolean|null} scrollXPossible - Indicates whether the content overflows horizontally and scrolling not blocked\n * @property {boolean|null} trackYVisible - Indicates whether vertical track is visible\n * @property {boolean|null} trackXVisible - Indicates whether horizontal track is visible\n * @property {boolean|null} isRtl - Indicates whether display direction is right-to-left\n */\n\nvar Scrollbar =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Scrollbar, _React$Component);\n\n  _createClass(Scrollbar, null, [{\n    key: \"computeThumbSize\",\n\n    /**\n     * Compute the thumb size\n     *\n     * @param {number} trackSize\n     * @param {number} scrollableSize\n     * @param {number} viewportSize\n     * @param {number} minimalSize\n     * @return {number}\n     */\n    value: function computeThumbSize(trackSize, scrollableSize, viewportSize, minimalSize) {\n      var size = Math.ceil(viewportSize / scrollableSize * trackSize) || 0;\n      return trackSize === size ? 0 : Math.max(size, minimalSize);\n    }\n    /**\n     * Compute the thumb offset from scroll value\n     *\n     * @param {number} trackSize\n     * @param {number} thumbSize\n     * @param {number} scrollableSize\n     * @param {number} viewportSize\n     * @param {number} scrollValue\n     * @return {number}\n     */\n\n  }, {\n    key: \"computeThumbOffset\",\n    value: function computeThumbOffset(trackSize, thumbSize, scrollableSize, viewportSize, scrollValue) {\n      return thumbSize && scrollValue / (scrollableSize - viewportSize) * (trackSize - thumbSize) || 0;\n    }\n    /**\n     * Compute the scroll value depending on thumb offset\n     *\n     * @param {number} trackSize\n     * @param {number} thumbSize\n     * @param {number} offset\n     * @param {number} scrollableSize\n     * @param {number} viewportSize\n     * @return {number}\n     */\n\n  }, {\n    key: \"computeScrollForOffset\",\n    value: function computeScrollForOffset(trackSize, thumbSize, offset, scrollableSize, viewportSize) {\n      return (offset - thumbSize / 2) / (trackSize - thumbSize) * (scrollableSize - viewportSize) || 0;\n    }\n  }]);\n\n  function Scrollbar(props) {\n    var _this;\n\n    _classCallCheck(this, Scrollbar);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Scrollbar).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleScrollEvent\", function () {\n      _this.scrollDetect();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"scrollDetect\", function () {\n      if (!_this.props.onScrollStart && !_this.props.onScrollStop) {\n        return;\n      }\n\n      !_this.scrollDetect.timeout && _this.props.onScrollStart && _this.props.onScrollStart.call(_assertThisInitialized(_assertThisInitialized(_this)), _this.getScrollValues());\n      _this.scrollDetect.timeout && clearTimeout(_this.scrollDetect.timeout);\n      _this.scrollDetect.timeout = setTimeout(function () {\n        _this.scrollDetect.timeout = null;\n        _this.props.onScrollStop && _this.props.onScrollStop.call(_assertThisInitialized(_assertThisInitialized(_this)), _this.getScrollValues());\n      }, _this.props.scrollDetectionThreshold);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"update\", function () {\n      var forced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // autodetect direction if not defined\n\n      if (typeof _this.state.isRtl !== \"boolean\") {\n        _this.setState({\n          isRtl: getComputedStyle(_this.contentEl).direction === \"rtl\"\n        });\n\n        return _this.getScrollValues();\n      }\n\n      var scrollValues = _this.getScrollValues(true),\n          prevScrollValues = _this.getScrollValues();\n\n      var bitmask = 0; // calculating bitmask\n\n      prevScrollValues.clientHeight !== scrollValues.clientHeight && (bitmask |= 1 << 0);\n      prevScrollValues.clientWidth !== scrollValues.clientWidth && (bitmask |= 1 << 1);\n      prevScrollValues.scrollHeight !== scrollValues.scrollHeight && (bitmask |= 1 << 2);\n      prevScrollValues.scrollWidth !== scrollValues.scrollWidth && (bitmask |= 1 << 3);\n      prevScrollValues.scrollTop !== scrollValues.scrollTop && (bitmask |= 1 << 4);\n      prevScrollValues.scrollLeft !== scrollValues.scrollLeft && (bitmask |= 1 << 5);\n      prevScrollValues.scrollYBlocked !== scrollValues.scrollYBlocked && (bitmask |= 1 << 6);\n      prevScrollValues.scrollXBlocked !== scrollValues.scrollXBlocked && (bitmask |= 1 << 7);\n      prevScrollValues.scrollYPossible !== scrollValues.scrollYPossible && (bitmask |= 1 << 8);\n      prevScrollValues.scrollXPossible !== scrollValues.scrollXPossible && (bitmask |= 1 << 9);\n      prevScrollValues.trackYVisible !== scrollValues.trackYVisible && (bitmask |= 1 << 10);\n      prevScrollValues.trackXVisible !== scrollValues.trackXVisible && (bitmask |= 1 << 11);\n      prevScrollValues.isRtl !== scrollValues.isRtl && (bitmask |= 1 << 12); // if not forced and nothing has changed - skip this step\n\n      if (bitmask === 0 && !forced) {\n        return prevScrollValues;\n      } // if updater return true - call callbacks and cache the scroll values\n\n\n      if ((_this.props.native ? _this.updaterNative : _this.updaterCustom).call(_assertThisInitialized(_assertThisInitialized(_this)), scrollValues, prevScrollValues, bitmask)) {\n        _this.scrollValues = scrollValues;\n        prevScrollValues.scrollTop !== null && _this.props.onScroll && _this.props.onScroll(scrollValues, prevScrollValues);\n      }\n\n      return prevScrollValues;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleTrackClick\", function (e, params) {\n      params.axis === _Track.TYPE_X && _this.props.trackXProps.onClick && _this.props.trackXProps.onClick(e, params);\n      params.axis === _Track.TYPE_Y && _this.props.trackYProps.onClick && _this.props.trackYProps.onClick(e, params);\n      var scrollTarget = params.axis === _Track.TYPE_X ? Scrollbar.computeScrollForOffset((0, _getInnerSizes.getInnerWidth)(_this.trackXEl), _this.thumbXEl.clientWidth, params.offset, _this.contentEl.scrollWidth, _this.contentEl.clientWidth) : Scrollbar.computeScrollForOffset((0, _getInnerSizes.getInnerHeight)(_this.trackYEl), _this.thumbYEl.clientHeight, params.offset, _this.contentEl.scrollHeight, _this.contentEl.clientHeight);\n\n      if (_this.props.trackClickBehavior === \"jump\") {\n        params.axis === _Track.TYPE_X && (_this.contentEl.scrollLeft = scrollTarget);\n        params.axis === _Track.TYPE_Y && (_this.contentEl.scrollTop = scrollTarget);\n      } else if (_this.props.trackClickBehavior === \"step\") {\n        params.axis === _Track.TYPE_X && (_this.contentEl.scrollLeft = _this.contentEl.scrollLeft < scrollTarget ? _this.contentEl.scrollLeft + _this.contentEl.clientWidth : _this.contentEl.scrollLeft - _this.contentEl.clientWidth);\n        params.axis === _Track.TYPE_Y && (_this.contentEl.scrollTop = _this.contentEl.scrollTop < scrollTarget ? _this.contentEl.scrollTop + _this.contentEl.clientHeight : _this.contentEl.scrollTop - _this.contentEl.clientHeight);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleThumbDragStart\", function (params) {\n      params.axis === _Track.TYPE_X && _this.props.thumbXProps.onDragStart && _this.props.thumbXProps.onDragStart(params);\n      params.axis === _Track.TYPE_Y && _this.props.thumbYProps.onDragStart && _this.props.thumbYProps.onDragStart(params);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleThumbDragEnd\", function (params) {\n      params.axis === _Track.TYPE_X && _this.props.thumbXProps.onDragEnd && _this.props.thumbXProps.onDragEnd(params);\n      params.axis === _Track.TYPE_Y && _this.props.thumbYProps.onDragEnd && _this.props.thumbYProps.onDragEnd(params);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleThumbDrag\", function (params) {\n      _this.scrollDetect();\n\n      if (params.axis === _Track.TYPE_X) {\n        _this.props.thumbXProps.onDrag && _this.props.thumbXProps.onDrag(params);\n        var trackWidth = (0, _getInnerSizes.getInnerWidth)(_this.trackXEl);\n        var offset = params.offset;\n\n        if (_this.state.isRtl) {\n          if (engine === \"Trident\" || engine === \"EdgeHTML\") {\n            offset = trackWidth - offset;\n          } else if (engine !== \"Blink\") {\n            offset -= _this.thumbXEl.clientWidth / 2;\n          }\n        }\n\n        _this.contentEl.scrollLeft = Scrollbar.computeScrollForOffset(trackWidth, _this.thumbXEl.clientWidth, offset, _this.contentEl.scrollWidth, _this.contentEl.clientWidth);\n      }\n\n      if (params.axis === _Track.TYPE_Y) {\n        _this.props.thumbYProps.onDrag && _this.props.thumbYProps.onDrag(params);\n        _this.contentEl.scrollTop = Scrollbar.computeScrollForOffset((0, _getInnerSizes.getInnerHeight)(_this.trackYEl), _this.thumbYEl.clientHeight, params.offset, _this.contentEl.scrollHeight, _this.contentEl.clientHeight);\n      }\n    });\n\n    _this.state = {\n      trackYVisible: true,\n      trackXVisible: true,\n      isRtl: _this.props.rtl\n    };\n    _this.scrollValues = _this.getScrollValues(true);\n    return _this;\n  }\n\n  _createClass(Scrollbar, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (this.props.rtl !== prevProps.rtl && this.props.rtl !== this.state.isRtl) {\n        this.setState({\n          isRtl: this.props.rtl\n        });\n      }\n\n      if (this.state.isRtl !== prevState.isRtl) {\n        this.update();\n      }\n\n      if (this.props.scrollTop !== prevProps.scrollTop) {\n        if (typeof this.props.scrollTop !== \"undefined\") {\n          this.contentEl.scrollTop = this.props.scrollTop;\n        }\n      }\n\n      if (this.props.scrollLeft !== prevProps.scrollLeft) {\n        if (typeof this.props.scrollLeft !== \"undefined\") {\n          this.contentEl.scrollLeft = this.props.scrollLeft;\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      _LoopController.default.registerScrollbar(this);\n\n      this.contentEl.addEventListener(\"scroll\", this.handleScrollEvent, {\n        passive: true\n      });\n\n      if (typeof this.props.scrollTop !== \"undefined\") {\n        this.contentEl.scrollTop = this.props.scrollTop;\n      }\n\n      if (typeof this.props.scrollLeft !== \"undefined\") {\n        this.contentEl.scrollLeft = this.props.scrollLeft;\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      _LoopController.default.unregisterScrollbar(this);\n\n      this.contentEl.removeEventListener(\"scroll\", this.handleScrollEvent, {\n        passive: true\n      });\n    }\n  }, {\n    key: \"scrollTo\",\n\n    /**\n     *  Set scroll at given coordinates\n     *\n     * @param {number} x\n     * @param {number} y\n     *\n     * @return {Scrollbar}\n     */\n    value: function scrollTo(y, x) {\n      this.contentEl.scrollTop = y;\n      this.contentEl.scrollLeft = x;\n      return this;\n    }\n    /**\n     *  Set viewport's center at given coordinates\n     *\n     * @param {number} x\n     * @param {number} y\n     *\n     * @return {Scrollbar}\n     */\n\n  }, {\n    key: \"centerAt\",\n    value: function centerAt(y, x) {\n      this.contentEl.scrollTop = y - this.contentEl.clientHeight / 2;\n      this.contentEl.scrollLeft = x - this.contentEl.clientWidth / 2;\n      return this;\n    }\n    /**\n     * Return the vertical scroll position\n     *\n     * @return {number}\n     */\n\n  }, {\n    key: \"scrollToTop\",\n\n    /**\n     * Scrol to the top border\n     *\n     * @return {Scrollbar}\n     */\n    value: function scrollToTop() {\n      if (this.contentEl) {\n        this.contentEl.scrollTop = 0;\n      }\n\n      return this;\n    }\n    /**\n     * Scroll to the bottom border\n     *\n     * @return {Scrollbar}\n     */\n\n  }, {\n    key: \"scrollToBottom\",\n    value: function scrollToBottom() {\n      if (this.contentEl) {\n        this.contentEl.scrollTop = this.contentEl.scrollHeight;\n      }\n\n      return this;\n    }\n    /**\n     * Scrolls to the left border\n     *\n     * @return {Scrollbar}\n     */\n\n  }, {\n    key: \"scrollToLeft\",\n    value: function scrollToLeft() {\n      if (this.contentEl) {\n        this.contentEl.scrollLeft = 0;\n      }\n\n      return this;\n    }\n    /**\n     * Scroll to the right border\n     *\n     * @return {Scrollbar}\n     */\n\n  }, {\n    key: \"scrollToRight\",\n    value: function scrollToRight() {\n      if (this.contentEl) {\n        this.contentEl.scrollLeft = this.contentEl.scrollWidth;\n      }\n\n      return this;\n    }\n    /**\n     * @param {boolean} force\n     *\n     * @return {ScrollValues}\n     */\n\n  }, {\n    key: \"getScrollValues\",\n    value: function getScrollValues() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!force) {\n        return this.scrollValues;\n      }\n\n      var scrollValues = {\n        clientHeight: null,\n        clientWidth: null,\n        scrollHeight: null,\n        scrollWidth: null,\n        scrollTop: null,\n        scrollLeft: null,\n        scrollYBlocked: null,\n        scrollXBlocked: null,\n        scrollYPossible: null,\n        scrollXPossible: null,\n        trackYVisible: null,\n        trackXVisible: null,\n        isRtl: null\n      };\n\n      if (this.contentEl) {\n        scrollValues.clientHeight = this.contentEl.clientHeight;\n        scrollValues.clientWidth = this.contentEl.clientWidth;\n        scrollValues.scrollHeight = this.contentEl.scrollHeight;\n        scrollValues.scrollWidth = this.contentEl.scrollWidth;\n        scrollValues.scrollTop = this.contentEl.scrollTop;\n        scrollValues.scrollLeft = this.contentEl.scrollLeft;\n        scrollValues.scrollYBlocked = this.props.noScroll || this.props.noScrollY;\n        scrollValues.scrollXBlocked = this.props.noScroll || this.props.noScrollX;\n        scrollValues.scrollYPossible = !scrollValues.scrollYBlocked && scrollValues.scrollHeight > scrollValues.clientHeight;\n        scrollValues.scrollXPossible = !scrollValues.scrollXBlocked && scrollValues.scrollWidth > scrollValues.clientWidth;\n        scrollValues.trackYVisible = scrollValues.scrollYPossible || this.props.permanentTracks || this.props.permanentTrackY;\n        scrollValues.trackXVisible = scrollValues.scrollXPossible || this.props.permanentTracks || this.props.permanentTrackX;\n        scrollValues.isRtl = this.state.isRtl;\n      }\n\n      return scrollValues;\n    }\n    /**\n     *\n     * @param forced\n     * @return {ScrollValues}\n     */\n\n  }, {\n    key: \"updaterCustom\",\n\n    /**\n     * @param {ScrollValues} scrollValues current scroll values\n     * @param {ScrollValues} prevScrollValues scroll values that been before the update process\n     * @param {number} bitmask bit mask that represents difference between prev scroll values and current ones\n     *\n     * @return {boolean} whether to save current scroll values or not\n     */\n    value: function updaterCustom(scrollValues, prevScrollValues, bitmask) {\n      // if scrollbars visibility has changed\n      if (bitmask & 1 << 10 || bitmask & 1 << 11) {\n        this.scrollValues.scrollYBlocked = scrollValues.scrollYBlocked;\n        this.scrollValues.scrollXBlocked = scrollValues.scrollXBlocked;\n        this.scrollValues.scrollYPossible = scrollValues.scrollYPossible;\n        this.scrollValues.scrollXPossible = scrollValues.scrollXPossible;\n        this.setState({\n          trackYVisible: this.scrollValues.trackYVisible = scrollValues.trackYVisible,\n          trackXVisible: this.scrollValues.trackXVisible = scrollValues.trackXVisible\n        });\n        return false;\n      } // if Y track rendered and changed anything related to scrollY\n\n\n      if (this.trackYEl) {\n        bitmask & 1 << 10 && (this.trackYEl.style.display = scrollValues.trackYVisible ? null : \"none\");\n\n        if (bitmask & 1 << 0 || bitmask & 1 << 2 || bitmask & 1 << 4 || bitmask & 1 << 6 || bitmask & 1 << 8) {\n          if (scrollValues.scrollYPossible) {\n            var trackSize = (0, _getInnerSizes.getInnerHeight)(this.trackYEl);\n            var thumbSize = Scrollbar.computeThumbSize(trackSize, scrollValues.scrollHeight, scrollValues.clientHeight, this.props.minimalThumbsSize);\n            var thumbOffset = Scrollbar.computeThumbOffset(trackSize, thumbSize, scrollValues.scrollHeight, scrollValues.clientHeight, scrollValues.scrollTop);\n            this.thumbYEl.style.transform = \"translateY(\".concat(thumbOffset, \"px)\");\n            this.thumbYEl.style.height = thumbSize + \"px\";\n            this.thumbYEl.style.display = null;\n          } else {\n            this.thumbYEl.style.transform = null;\n            this.thumbYEl.style.height = \"0px\";\n            this.thumbYEl.style.display = \"none\";\n          }\n        }\n      } // if X track rendered and changed anything related to scrollX\n\n\n      if (this.trackXEl) {\n        bitmask & 1 << 11 && (this.trackXEl.style.display = scrollValues.trackXVisible ? null : \"none\");\n\n        if (bitmask & 1 << 1 || bitmask & 1 << 3 || bitmask & 1 << 5 || bitmask & 1 << 7 || bitmask & 1 << 9) {\n          if (scrollValues.scrollXPossible) {\n            var _trackSize = (0, _getInnerSizes.getInnerWidth)(this.trackXEl);\n\n            var _thumbSize = Scrollbar.computeThumbSize(_trackSize, scrollValues.scrollWidth, scrollValues.clientWidth, this.props.minimalThumbsSize);\n\n            var _thumbOffset = Scrollbar.computeThumbOffset(_trackSize, _thumbSize, scrollValues.scrollWidth, scrollValues.clientWidth, scrollValues.scrollLeft);\n\n            if (this.state.isRtl) {\n              if (engine === \"Blink\") {\n                _thumbOffset = _thumbSize + _thumbOffset - _trackSize;\n              } else if (engine === \"Trident\" || engine === \"EdgeHTML\") {\n                _thumbOffset *= -1;\n              }\n            }\n\n            this.thumbXEl.style.transform = \"translateX(\".concat(_thumbOffset, \"px)\");\n            this.thumbXEl.style.width = _thumbSize + \"px\";\n            this.thumbXEl.style.display = null;\n          } else {\n            this.thumbXEl.style.transform = null;\n            this.thumbXEl.style.width = \"0px\";\n            this.thumbXEl.style.display = \"none\";\n          }\n        }\n      }\n\n      if (this.props.translateContentSizesToHolder && this.holderEl && (bitmask & 1 << 2 || bitmask & 1 << 3)) {\n        this.holderEl.style.width = scrollValues.scrollWidth + \"px\";\n        this.holderEl.style.height = scrollValues.scrollHeight + \"px\";\n      }\n\n      return true;\n    }\n    /**\n     * @param {ScrollValues} scrollValues current scroll values\n     * @param {ScrollValues} prevScrollValues scroll values that been before the update process\n     *\n     * @param {number} bitmask bit mask that represents difference between prev scroll values and current ones\n     */\n\n  }, {\n    key: \"updaterNative\",\n    value: function updaterNative(scrollValues, prevScrollValues, bitmask) {\n      return true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          native = _this$props.native,\n          minimalThumbsSize = _this$props.minimalThumbsSize,\n          fallbackScrollbarWidth = _this$props.fallbackScrollbarWidth,\n          scrollDetectionThreshold = _this$props.scrollDetectionThreshold,\n          tagName = _this$props.tagName,\n          className = _this$props.className,\n          style = _this$props.style,\n          trackClickBehavior = _this$props.trackClickBehavior,\n          rtl = _this$props.rtl,\n          momentum = _this$props.momentum,\n          noDefaultStyles = _this$props.noDefaultStyles,\n          translateContentSizesToHolder = _this$props.translateContentSizesToHolder,\n          scrollLeft = _this$props.scrollLeft,\n          scrollTop = _this$props.scrollTop,\n          noScrollX = _this$props.noScrollX,\n          noScrollY = _this$props.noScrollY,\n          noScroll = _this$props.noScroll,\n          permanentTrackX = _this$props.permanentTrackX,\n          permanentTrackY = _this$props.permanentTrackY,\n          permanentTracks = _this$props.permanentTracks,\n          removeTracksWhenNotUsed = _this$props.removeTracksWhenNotUsed,\n          removeTrackYWhenNotUsed = _this$props.removeTrackYWhenNotUsed,\n          removeTrackXWhenNotUsed = _this$props.removeTrackXWhenNotUsed,\n          propsWrapperProps = _this$props.wrapperProps,\n          propsContentProps = _this$props.contentProps,\n          propsTrackXProps = _this$props.trackXProps,\n          propsTrackYProps = _this$props.trackYProps,\n          propsThumbXProps = _this$props.thumbXProps,\n          propsThumbYProps = _this$props.thumbYProps,\n          wrapperRenderer = _this$props.wrapperRenderer,\n          contentRenderer = _this$props.contentRenderer,\n          trackXRenderer = _this$props.trackXRenderer,\n          trackYRenderer = _this$props.trackYRenderer,\n          thumbXRenderer = _this$props.thumbXRenderer,\n          thumbYRenderer = _this$props.thumbYRenderer,\n          onScroll = _this$props.onScroll,\n          onScrollStart = _this$props.onScrollStart,\n          onScrollStop = _this$props.onScrollStop,\n          children = _this$props.children,\n          props = _objectWithoutProperties(_this$props, [\"native\", \"minimalThumbsSize\", \"fallbackScrollbarWidth\", \"scrollDetectionThreshold\", \"tagName\", \"className\", \"style\", \"trackClickBehavior\", \"rtl\", \"momentum\", \"noDefaultStyles\", \"translateContentSizesToHolder\", \"scrollLeft\", \"scrollTop\", \"noScrollX\", \"noScrollY\", \"noScroll\", \"permanentTrackX\", \"permanentTrackY\", \"permanentTracks\", \"removeTracksWhenNotUsed\", \"removeTrackYWhenNotUsed\", \"removeTrackXWhenNotUsed\", \"wrapperProps\", \"contentProps\", \"trackXProps\", \"trackYProps\", \"thumbXProps\", \"thumbYProps\", \"wrapperRenderer\", \"contentRenderer\", \"trackXRenderer\", \"trackYRenderer\", \"thumbXRenderer\", \"thumbYRenderer\", \"onScroll\", \"onScrollStart\", \"onScrollStop\", \"children\"]);\n\n      var _this$state = this.state,\n          trackXVisible = _this$state.trackXVisible,\n          trackYVisible = _this$state.trackYVisible;\n      var scrollValues = this.getScrollValues();\n\n      if (native) {\n        return _react.default.createElement(_NativeScrollbar.default, _extends({\n          rtl: rtl,\n          momentum: momentum,\n          permanentTrackX: permanentTrackX,\n          permanentTrackY: permanentTrackY,\n          permanentTracks: permanentTracks,\n          noScrollX: noScrollX,\n          noScrollY: noScrollY,\n          noScroll: noScroll,\n          tagName: tagName,\n          className: (trackYVisible ? \" trackYVisible\" : \"\") + (trackYVisible ? \" trackXVisible\" : \"\") + (className ? \" \" + className : \"\"),\n          style: style,\n          elementRef: function elementRef(ref) {\n            return _this2.contentEl = ref;\n          },\n          onScroll: this.handleScrollEvent,\n          children: children\n        }, props));\n      }\n\n      var browserSBW = (0, _getScrollbarWidth.default)();\n      var scrollbarWidth = browserSBW || fallbackScrollbarWidth;\n\n      var wrapperProps = _objectSpread({}, propsWrapperProps),\n          contentProps = _objectSpread({}, propsContentProps),\n          trackXProps = _objectSpread({}, propsTrackXProps),\n          trackYProps = _objectSpread({}, propsTrackYProps),\n          thumbXProps = _objectSpread({}, propsThumbXProps),\n          thumbYProps = _objectSpread({}, propsThumbYProps);\n\n      wrapperProps.key = \"wrapper\";\n      contentProps.key = \"content\";\n      trackXProps.key = \"trackX\";\n      trackYProps.key = \"trackY\";\n      thumbXProps.key = \"thumbX\";\n      thumbYProps.key = \"thumbY\";\n\n      if (!noDefaultStyles) {\n        var _objectSpread2;\n\n        props.style = _objectSpread({}, defaultStyles.holder);\n        wrapperProps.style = _objectSpread({}, defaultStyles.wrapper, (_objectSpread2 = {}, _defineProperty(_objectSpread2, this.state.isRtl ? \"marginLeft\" : \"marginRight\", trackYVisible ? 8 : null), _defineProperty(_objectSpread2, \"marginBottom\", trackXVisible ? 8 : null), _objectSpread2));\n        trackXProps.style = _objectSpread({}, defaultStyles.track.common, defaultStyles.track.x);\n        trackYProps.style = _objectSpread({}, defaultStyles.track.common, defaultStyles.track.y, _defineProperty({}, this.state.isRtl ? \"left\" : \"right\", 0));\n        thumbXProps.style = _objectSpread({}, defaultStyles.thumb.common, defaultStyles.thumb.x);\n        thumbYProps.style = _objectSpread({}, defaultStyles.thumb.common, defaultStyles.thumb.y);\n      }\n\n      props.style = _objectSpread({}, props.style, style, typeof rtl !== \"undefined\" && {\n        direction: rtl ? \"rtl\" : \"ltr\"\n      });\n      wrapperProps.style = _objectSpread({}, wrapperProps.style, propsWrapperProps.style, {\n        position: \"relative\",\n        overflow: \"hidden\"\n      });\n      contentProps.style = _objectSpread({}, defaultStyles.content, propsContentProps.style, momentum && {\n        WebkitOverflowScrolling: \"touch\"\n      }, {\n        overflowY: scrollValues.scrollYPossible ? \"scroll\" : \"hidden\",\n        overflowX: scrollValues.scrollXPossible ? \"scroll\" : \"hidden\"\n      }, this.state.isRtl ? {\n        paddingLeft: !browserSBW && scrollValues.scrollYPossible ? scrollbarWidth : null,\n        marginLeft: scrollValues.scrollYPossible ? -scrollbarWidth : null\n      } : {\n        paddingRight: !browserSBW && scrollValues.scrollYPossible ? scrollbarWidth : null,\n        marginRight: scrollValues.scrollYPossible ? -scrollbarWidth : null\n      }, {\n        paddingBottom: !browserSBW && scrollValues.scrollXPossible ? scrollbarWidth : null,\n        marginBottom: scrollValues.scrollXPossible ? -scrollbarWidth : null\n      });\n      trackXProps.style = _objectSpread({}, trackXProps.style, propsTrackXProps.style, !trackXVisible && {\n        display: \"none\"\n      });\n      trackYProps.style = _objectSpread({}, trackYProps.style, propsTrackYProps.style, !trackYVisible && {\n        display: \"none\"\n      });\n      thumbXProps.style = _objectSpread({}, thumbXProps.style, propsThumbXProps.style);\n      thumbYProps.style = _objectSpread({}, thumbYProps.style, propsThumbYProps.style);\n      props.className = \"ScrollbarsCustom\" + (trackYVisible ? \" trackYVisible\" : \"\") + (trackYVisible ? \" trackXVisible\" : \"\") + (this.state.isRtl ? \" rtl\" : \"\") + (className ? \" \" + className : \"\");\n      contentProps.className = \"content\" + (contentProps.className ? \" \" + contentProps.className : \"\");\n      wrapperProps.className = \"wrapper\" + (wrapperProps.className ? \" \" + wrapperProps.className : \"\");\n\n      props.ref = function (ref) {\n        _this2.holderEl = ref;\n      };\n\n      wrapperProps[wrapperRenderer ? \"elementRef\" : \"ref\"] = function (ref) {\n        _this2.wrapperEl = ref;\n      };\n\n      contentProps[contentRenderer ? \"elementRef\" : \"ref\"] = function (ref) {\n        _this2.contentEl = ref;\n      };\n\n      trackXProps.elementRef = function (ref) {\n        _this2.trackXEl = ref;\n      };\n\n      trackYProps.elementRef = function (ref) {\n        _this2.trackYEl = ref;\n      };\n\n      thumbXProps.elementRef = function (ref) {\n        _this2.thumbXEl = ref;\n      };\n\n      thumbYProps.elementRef = function (ref) {\n        _this2.thumbYEl = ref;\n      };\n\n      trackXProps.renderer = trackXRenderer;\n      trackYProps.renderer = trackYRenderer;\n      thumbXProps.renderer = thumbXRenderer;\n      thumbYProps.renderer = thumbYRenderer;\n      trackYProps.onClick = trackXProps.onClick = this.handleTrackClick;\n      thumbYProps.onDragStart = thumbXProps.onDragStart = this.handleThumbDragStart;\n      thumbYProps.onDragEnd = thumbXProps.onDragEnd = this.handleThumbDragEnd;\n      thumbYProps.onDrag = thumbXProps.onDrag = this.handleThumbDrag;\n      contentProps.children = children;\n      wrapperProps.children = contentRenderer ? contentRenderer(contentProps) : _react.default.createElement(\"div\", contentProps);\n      return _react.default.createElement(this.props.tagName, props, wrapperRenderer ? wrapperRenderer(wrapperProps) : _react.default.createElement(\"div\", wrapperProps), (trackYVisible || !(removeTracksWhenNotUsed && removeTrackYWhenNotUsed)) && _react.default.createElement(_Track.default, _extends({\n        type: _Track.TYPE_Y\n      }, trackYProps), _react.default.createElement(_Thumb.default, _extends({\n        type: _Track.TYPE_Y\n      }, thumbYProps))), (trackXVisible || !(removeTracksWhenNotUsed && removeTrackXWhenNotUsed)) && _react.default.createElement(_Track.default, _extends({\n        type: _Track.TYPE_X\n      }, trackXProps), _react.default.createElement(_Thumb.default, _extends({\n        type: _Track.TYPE_X\n      }, thumbXProps))));\n    }\n  }, {\n    key: \"scrollTop\",\n    get: function get() {\n      if (this.contentEl) {\n        return this.contentEl.scrollTop;\n      }\n\n      return 0;\n    }\n    /**\n     *\n     * Set the vertical scroll to given amount of pixels\n     *\n     * @param top {number} Pixels amount\n     */\n    ,\n    set: function set(top) {\n      if (this.contentEl) {\n        this.contentEl.scrollTop = top;\n        this.update();\n      }\n    }\n    /**\n     * Return the horizontal scroll position\n     *\n     * @return {number}\n     */\n\n  }, {\n    key: \"scrollLeft\",\n    get: function get() {\n      if (this.contentEl) {\n        return this.contentEl.scrollLeft;\n      }\n\n      return 0;\n    }\n    /**\n     * Set the horizontal scroll to given amount of pixels\n     *\n     * @param left {number} Pixels amount\n     */\n    ,\n    set: function set(left) {\n      if (this.contentEl) {\n        this.contentEl.scrollLeft = left;\n      }\n    }\n    /**\n     * @return {number}\n     */\n\n  }, {\n    key: \"scrollHeight\",\n    get: function get() {\n      if (this.contentEl) {\n        return this.contentEl.scrollHeight;\n      }\n\n      return 0;\n    }\n    /**\n     * @return {number}\n     */\n\n  }, {\n    key: \"scrollWidth\",\n    get: function get() {\n      if (this.contentEl) {\n        return this.contentEl.scrollWidth;\n      }\n\n      return 0;\n    }\n    /**\n     * @return {number}\n     */\n\n  }, {\n    key: \"clientHeight\",\n    get: function get() {\n      if (this.contentEl) {\n        return this.contentEl.clientHeight;\n      }\n\n      return 0;\n    }\n    /**\n     * @return {number}\n     */\n\n  }, {\n    key: \"clientWidth\",\n    get: function get() {\n      if (this.contentEl) {\n        return this.contentEl.clientWidth;\n      }\n\n      return 0;\n    }\n  }]);\n\n  return Scrollbar;\n}(_react.default.Component);\n\nexports.default = Scrollbar;\n\n_defineProperty(Scrollbar, \"propTypes\", {\n  native: _propTypes.default.bool,\n  minimalThumbsSize: _propTypes.default.number,\n  fallbackScrollbarWidth: _propTypes.default.number,\n  tagName: _propTypes.default.string,\n  className: _propTypes.default.string,\n  style: _propTypes.default.object,\n  trackClickBehavior: _propTypes.default.oneOf([\"jump\", \"step\"]),\n  rtl: _propTypes.default.bool,\n  momentum: _propTypes.default.bool,\n  noDefaultStyles: _propTypes.default.bool,\n  scrollDetectionThreshold: _propTypes.default.number,\n  translateContentSizesToHolder: _propTypes.default.bool,\n  scrollTop: _propTypes.default.number,\n  scrollLeft: _propTypes.default.number,\n  noScrollX: _propTypes.default.bool,\n  noScrollY: _propTypes.default.bool,\n  noScroll: _propTypes.default.bool,\n  removeTracksWhenNotUsed: _propTypes.default.bool,\n  removeTrackYWhenNotUsed: _propTypes.default.bool,\n  removeTrackXWhenNotUsed: _propTypes.default.bool,\n  permanentTrackX: _propTypes.default.bool,\n  permanentTrackY: _propTypes.default.bool,\n  permanentTracks: _propTypes.default.bool,\n  wrapperProps: _propTypes.default.object,\n  contentProps: _propTypes.default.object,\n  trackXProps: _propTypes.default.object,\n  trackYProps: _propTypes.default.object,\n  thumbXProps: _propTypes.default.object,\n  thumbYProps: _propTypes.default.object,\n  wrapperRenderer: _propTypes.default.func,\n  contentRenderer: _propTypes.default.func,\n  trackXRenderer: _propTypes.default.func,\n  trackYRenderer: _propTypes.default.func,\n  thumbXRenderer: _propTypes.default.func,\n  thumbYRenderer: _propTypes.default.func,\n  onScroll: _propTypes.default.func,\n  onScrollStart: _propTypes.default.func,\n  onScrollStop: _propTypes.default.func\n});\n\n_defineProperty(Scrollbar, \"defaultProps\", {\n  native: false,\n  tagName: \"div\",\n  minimalThumbsSize: 30,\n  fallbackScrollbarWidth: 20,\n  trackClickBehavior: \"jump\",\n  momentum: true,\n  noDefaultStyles: false,\n  scrollDetectionThreshold: 100,\n  translateContentSizesToHolder: false,\n  noScrollX: false,\n  noScrollY: false,\n  noScroll: false,\n  permanentTrackX: false,\n  permanentTrackY: false,\n  permanentTracks: false,\n  removeTracksWhenNotUsed: true,\n  removeTrackYWhenNotUsed: true,\n  removeTrackXWhenNotUsed: true,\n  wrapperProps: {},\n  contentProps: {},\n  trackXProps: {},\n  trackYProps: {},\n  thumbXProps: {},\n  thumbYProps: {}\n});","map":null,"metadata":{},"sourceType":"script"}